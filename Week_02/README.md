学习笔记

####HashMap 的小总结

-概念及数据存储结构

	概念：hash_map是用来存储key-value键值对的集合，每一个键值对是一个Entry，这些Entry分散存储在一个数组中  ；
	核心技术：直接存址和解决冲突
	存储结构：分散的桶结构，每个桶节点中同时可以存放一个单链表（该链表使用头插法生成，主要是为了解决散列冲突      的问题）

-说明一下hash_map在实际使用中需要注意的点

	hash_map的key尽量使用简单类，尽量不要使用自定义对象作为hsh_map的key，因为构造和拷贝构造会花费很大的时间，如若必需要，则使用对象的地址或指针，但是此时需要重写比较仿函数（下文会介绍）。
	hash_map的初始长度为16，后期动态增长的长度也应该是^{^{}}^{^{}}2^n；
	hash_map在高并发情况下可能会出现死锁；
	hash_map并不是标准模板库中的结构，C++ 11 版本及以后只是对其进行了支持，但是不同版本的编译器实现方式上可能不同，所以如果代码有跨平台需求的话，请尽量不要使用。

####1.前序遍历迭代算法：

-二叉树的前序遍历

二叉树的遍历，整体上看都是好理解的。

三种遍历的迭代写法中，数前序遍历最容易理解。

递归思路：先树根，然后左子树，然后右子树。每棵子树递归。

在迭代算法中，思路演变成，每到一个节点 A，就应该立即访问它。

因为，每棵子树都先访问其根节点。对节点的左右子树来说，也一定是先访问根。

在 A 的两棵子树中，遍历完左子树后，再遍历右子树。

因此，在访问完根节点后，遍历左子树前，要将右子树压入栈。

####2.中序遍历迭代算法：
-二叉树的中序遍历
思路：每到一个节点 A，因为根的访问在中间，将 A 入栈。然后遍历左子树，接着访问 A，最后遍历右子树。

在访问完 A 后，A 就可以出栈了。因为 A 和其左子树都已经访问完成。

####3.两数之和
解题思路

    1、根据对leetcode的经验了解，一般循环从后往前，会得到更好的速度收益，因此我们从最后向前遍历，这算是利用数据特性吧
    2、我们使用unordered_map，对差值进行存储，效率比map高
    3、对于unordered_map的查找，不宜使用[key]的方式，这样会进行两次查找浪费时间，而应该使用iter，通过!=end()判断是否找到，通过iter->second直接拿到数据，一次查找操作
    4、我们存储到map中的数据是diff（差值）。这样尽可能的减少计算diff的操作（比如iter != end满足条件时，diff是不需要计算的）
